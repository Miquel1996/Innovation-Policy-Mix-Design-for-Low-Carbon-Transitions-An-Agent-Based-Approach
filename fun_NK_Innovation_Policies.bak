//#define EIGENLIB			// uncomment to use Eigen linear algebra library

#include"fun_head_fast.h"

// do not add Equations in this area

MODELBEGIN

//insert your equations here,ONLY between the MODELBEGIN and MODELEND words

//INITIALIZATION

EQUATION("init_landscape")
/*
Comment: Model initialization: create landscape.
*/
v[1] = VS(PARENT,"N");//Number of components in the NK landscape. Global parameter,in number of components,positive integer.
v[2] = VS(PARENT,"K");//Number of components whose state influence the performance contribution of a component in the NK landscape. Global parameter,in number of components,integer between 1 and N.
v[3] = VS(PARENT,"Correlation");//Correlation coefficient between unit costs and emissions intensity in the NK landscape. Global parameter,correlation coefficient between [-1,1].
v[4] = VS(PARENT,"Skewness");//Skewness adjustment for unit cost and emissions intensity distributions in the NK landscape. Global parameter,scale,positive real value.
CYCLES(THIS,cur,"Landscape_Matrix")//Cycle thorugh itself: This object contains all performance values in the fitness landscape.
{
	v[10] = 0;//Counter to create descending object.
	CYCLES(cur,cur1,"Matrix_Columns")//Create matrix rows (number of components N)
	{
		v[10]++;//counting 
		if (v[10]==1)//just model existing
		{
			v[10] = floor(v[1]);//create N
			v[10] = fmax(2,v[10]);//no less than 2 
			ADDNOBJS(cur,"Matrix_Columns",v[10]-1);//create N objects
		}
		WRITES(cur1,"column_ID",max(0,v[10]-v[1]));//Write column ID. Column parameter,integer in [0,N-1].
		v[11] = pow(2,v[2]);//Number of state combinations of component n and the other Kn components to which n depends on.
		v[20] = 0;//Counter to create descending object.
		CYCLES(cur1,cur2,"Matrix_Rows")//Create matrix rows (number of state combinations that define the performance contribution of a component)
		{
			v[20]++;//counting 
			if (v[20]==1)//just model existing
			{
				v[20] = floor(pow(2,v[2]));//create 2^Kn
				v[20] = fmax(2,v[20]);//no less than 2
				ADDNOBJS(cur1,"Matrix_Rows",v[20]-1);//create 2^Kn objects
			}
			WRITES(cur2,"row_ID",max(0,v[20]-v[11]));//Write value ID corresponding to a unique state combination of a component and its partners. Row parameter,integer in [0,2^K-1]
			WRITES(cur2,"cost_contribution_kn",pow(uniform(0,1),v[4]));//Print component fitness contribution (adjusted to the skewness)
		}
	}
}
CYCLES(THIS,cur,"Landscape_Matrix")//Cycle through itself to generate the correlated value of emissions intensity
{
	CYCLES(cur,cur1,"Matrix_Columns")//For each column...
	{
		CYCLES(cur1,cur2,"Matrix_Rows")//And each row...
		{
			WRITES(cur2,"emissions_contribution_kn",(VS(cur2,"cost_contribution_kn")*v[3]+pow(uniform(0,1),v[4])*pow(1-pow(v[3],2),0.5)-min(0,v[3]))/(abs(v[3])+pow(1-pow(v[3],2),0.5)));//Define carbon intensity as a value correlated to cost by rho,keeping the same standard deviation,maximum,and minimum values.
		}
	}
}
PARAMETER//After initializing,convert this action into a parameter to not be repeated again.
RESULT(1)//Irrelevant result

EQUATION("init_market")
/*
Comment: Model initialization: create market.
*/
v[1] = VS(PARENT,"N");//Number of components in the NK landscape. Global parameter,in number of components,positive integer.
v[2] = VS(PARENT,"J");//Number of firms. Global parameter,in number of firms,positive integer.
v[3] = VS(PARENT,"M");//Firm memory capacity. Global parameter,in memory slots,positive integer.
v[4] = VS(PARENT,"cost_min");//Lower bound for unit production costs in the NK landscape. Global parameter,in money/unit,real value in (0,cost_max)
v[5] = VS(PARENT,"cost_max");//Upper bound for unit production costs in the NK ladnscape. Global parameter,in money/unit,real positive value.
v[6] = VS(PARENT,"emissions_min");//Lower bound for emissions intensity in the NK landscape. Global parameter in CO2/unit,real value in (0,emissions_max)
v[7] = VS(PARENT,"emissions_max");//Upper bound for emissions intensity in the NK landscape. Global parameter in CO2/unit,real positive value.
v[8] = VS(PARENT,"markup");//Initial mark-up for all firms (market mark-up at initialization). Global parameter in percent,positive real value.
v[9] = VS(PARENT,"carbon_sensitivity");//Consumer utility sensitivity to carbon emissions. Global parameter in money/CO2,positive real value.
CYCLES(THIS,cur,"Market")//Cycle thorugh itself to create "Research_Park_Advertisement","Firms" and initalize some variables.
{
	v[10] = 0;//Counter to create descending object (firms)
	v[70] = 0;//Counter to create descending object (research park advertisement)
	WRITES(cur,"emissions_legal_t",v[7]);//Initialize the maximum emissions intensity allowed as the maximum possible.
	CYCLES(cur,cur7,"Research_Park_Advertisement")//Create object Research Park Advertisement. For each component,the research park makes an expectation of what state delivers a low-carbon technology. 
	{
		v[70]++;//Counting
		if(v[70]==1)//Just model existing
		{
			v[70] = floor(v[1]);//Create N
			v[70] = fmax(2,v[70]);//No less than 2
			ADDNOBJS(cur,"Research_Park_Advertisement",v[70]-1);//Create N objects
		}
		WRITES(cur7,"advertisement_ID",max(0,v[70]-v[1]));//Define the ID of the advertised component. Research_Park_Advertisement parameter,integer in [0,N-1].
		WRITES(cur7,"advertised_state_nt",-1);//Initialize the Research park advertised state for a low-carbon good at -1 (i.e. no advertisement)
	}
	CYCLES(cur,cur1,"Firms")//Create object Firms. Firms search for new technologies,select one to compete with based on their expected consumer carbon sensitivity,and adjust mark-ups,carbon sensitivity expectations and budget.
	{
		v[10]++;//counting
		if(v[10]==1)//just model existing
		{
			v[10] = floor(v[2]);//create J
			v[10] = fmax(2,v[10]);//no less than 2 
			ADDNOBJS(cur,"Firms",v[10]-1);//create J objects
		}
		WRITES(cur1,"firm_ID",max(0,v[10]-v[2]));//Write the firm's ID. Firm parameter,integer in [0,J-1].
		WRITES(cur1,"cost_implemented_jt",v[5]);//Set initial cost as the highest possible (implemented technology).
		WRITES(cur1,"cost_explored_jt",v[5]);//Set initial cost as the highest possible (explored technology).
		WRITES(cur1,"cost_location_jt",v[5]);//Set initial cost as the highest possible (location technology).
		WRITES(cur1,"emissions_implemented_jt",v[7]);//Set initial emissions intensity as the highest possible (implemented technology).
		WRITES(cur1,"emissions_explored_jt",v[7]);//Set initial emissions intensity as the highest possible (explored technology).
		WRITES(cur1,"emissions_location_jt",v[7]);//Set initial emissions intensity as the highest possible (location technology).
		WRITES(cur1,"fitness_explored_jt",pow(v[5]+v[7]*v[9],-1));//Set initial fitness as the highest possible (explored technology).
		WRITES(cur1,"fitness_location_jt",pow(v[5]+v[7]*v[9],-1));//Set initial fitness as the highest possible (location technology).		
		WRITES(cur1,"technology_implemented_jt",-2);//Set initial technology ID as an empty technology (implemented technology).
		WRITES(cur1,"technology_explored_jt",-2);//Set initial technology ID as an empty technology (explored technology).
		WRITES(cur1,"technology_location_jt",-2);//Set initial technology ID as an empty technology (location technology).
		WRITES(cur1,"budget_jt",0);//Set initial budget to 0.
		if(VS(cur1,"firm_ID") != 0)//The first firm ID is not 0 (such firm is considered "dead" to avoid monopoly)
		{
			WRITES(cur1,"market_share_jt",1/(v[2]-1));//Set Initial market share as fair market share
			WRITES(cur1,"markup_jt",v[8]);//Set Initial mark-up to the market mark-up.
			WRITES(cur1,"carbon_sensitivity_jt",v[9]);//Set initial weight to expected consumer sensitivity to carbon emissions to the true value.
			WRITES(cur1,"units_produced_jt",VS(PARENT,"units_produced_t")/(v[2]-1));//Set initial units produced in consistence with initialization assumptions.
		}
		if(VS(cur1,"firm_ID") == 0)//If the firm has ID zero,it starts as dead.
			WRITES(cur1,"dead_jt",1);//Identify as dead				
		v[20] = 0;//Counter to create descending object (Competitors).
		v[30] = 0;//Counter to create descending object (Memory).
		v[40] = 0;//Counter to create descending object (Search).
		CYCLES(cur1,cur2,"Competitors")//Create an object (descending form firms) with the necessary information to update the carbon preference expectation
		{
			v[20]++;//counting 
			if(v[20]==1)//just model existing
			{
				v[20] = floor(v[2]);//create J
				v[20] = fmax(2,v[20]);//no less than 2 
				ADDNOBJS(cur1,"Competitors",v[20]-1);//create J objects
			}
			WRITES(cur2,"competitor_ID",max(0,v[20]-v[2]));//Write competitor ID,integer from 0 to J-1
			if(VS(cur2,"competitor_ID") != 0 && VS(cur2,"competitor_ID") != VS(cur1,"firm_ID"))//Exclude empty competitor and own firm
				WRITES(cur2,"score_competitor_hjt",1);//Write initial selection score: initially the same for everyone	
		}
		CYCLES(cur1,cur3,"Memory")//Create an object (descending from firms) containing the technology memory.
		{
			v[30]++;//counting 
			if(v[30]==1)//just model existing
			{
				v[30] = floor(v[3]);//create M
				v[30] = fmax(2,v[30]);//no less than 2 
				ADDNOBJS(cur1,"Memory",v[30]-1);//create M objects
			}
			WRITES(cur3,"memory_ID",max(0,v[30]-v[3]));//Write memory slot ID,integer from 0 to M-1
			WRITES(cur3,"cost_mjt",v[5]);//Set default cost as the maximum.
			WRITES(cur3,"emissions_mjt",v[7]);//Set default emissions as the maximum.
			WRITES(cur3,"fitness_mjt",pow(v[5]+v[7]*v[9],-1));//Set default fitness in consistence with initialization assumptions.
			WRITES(cur3,"technology_mjt",-1);//Technology ID = -1 means that the memory slot is empty
		}
		CYCLES(cur1,cur4,"Search_Components")//Create an object (descending from firms) containing the information for the firm search of new technologies.
		{
			v[40]++;	//counting 
			if(v[40]==1)//just model existing
			{
				v[40] = floor(v[1]);//create N
				v[40] = fmax(2,v[40]);//no less than 2 
				ADDNOBJS(cur1,"Search_Components",v[40]-1);//create N objects
			}
			WRITES(cur4,"component_ID",max(0,v[40]-v[1]));//Write component IDm ubteger from 0 to M-1
			v[41] = VS(PARENT,"K");//Number of components whose state influence the performance contribution of a component in the NK landscape. Global parameter,in number of components,integer between 1 and N.
			WRITES(cur4,"cost_explored_njt",1);//Set initial cost contribution as the highest (explored technology)
			WRITES(cur4,"cost_location_njt",1);//Set initial cost contribution as the highest (explored technology)
			WRITES(cur4,"emissions_location_njt",1);//Set initial pollution contribution as the highest (location technology)
			WRITES(cur4,"emissions_explored_njt",1);//Set initial pollution contribution as the highest (explored technology)
			v[50] = 0;//Counter to create descending object (Search_Partners)
			CYCLES(cur4,cur5,"Search_Partners")//Create an object (descending from search) containing the informaiton of the components that influence a component's performance contribution
			{
				v[50]++;//counting
				if(v[50]==1)//just model existing
				{
					v[50] = floor(v[41]);//create K objects
					v[50] = fmax(1,v[50]);//no less than 1 
					ADDNOBJS(cur4,"Search_Partners",v[50]-1);//create objects
				}
				WRITES(cur5,"partner_position",max(0,v[41]-1-(v[50]-v[41])));//Write partner position in the state-string formed by parent component and its partners,integer from Kn-1 to 0 (reverse order).
				v[51] = v[41]-1-VS(cur5,"partner_position")+VS(cur4,"component_ID");//Un-adjusted partner position in the state-string formed by parent component and its partners 
				if(v[51]>(v[1]-1))//Identify the component ID of the partner,selecting the Kn next components of component n.
					WRITES(cur5,"partner_component_ID",v[51]-v[1]);//Apply toroidal if needed.
					else
					WRITES(cur5,"partner_component_ID",v[51]);//Else,do not.
			}
		}	
	}
}
PARAMETER//After initializing,convert this action into a parameter to not be repeated again.
RESULT(1)//Irrelevant result

//SELECTION & EVALUATION OF TECHNOLOGIES

EQUATION("allowed_mjt")
/*
Comment: The technology is not listed as accepted. Memory variable (boolean: 1=accepted,0=banned)
*/
v[1] = VS(THIS,"technology_mjt");//Technology ID. Memory variable,ID from 0 to 2^N.
v[2] = VS(THIS,"emissions_mjt");//Technology carbon intensity. Memory variable,in C02/unit from emissions_min to emissions_max.
v[3] = VS(GRANDPARENT,"emissions_legal_t");//Carbon standard. Market variable,in CO2/unit from emissions_target to emissions_max.
if(v[2] > v[3] || v[1] < 0)//If the technology exists and pollutes above the legal threshold
	v[0] = 0;//It is not accepted.
	else
	v[0] = 1;//It is accepted.
RESULT(v[0])

EQUATION("fitness_mjt")
/*
Comment: Expected fitness. Memory variable in fitness measure,real positive value.
*/
v[1] = VLS(PARENT,"carbon_sensitivity_jt",1);//Subjective weight to carbon emissions. Lagged firm variable,in money/CO2,real positive value.
v[2] = VS(THIS,"cost_mjt");//Cost per unit. In money/unit,from cost_min to cost_max.
v[3] = VS(THIS,"emissions_mjt");//Emissions per unit. In emissions/unit,from emissions_min to emissions_max.
v[4] = V("Carbon_Tax");//Carbon tax. Global parameter,in money/CO2,real positive value.
v[5] = V("Carbon_Target");//Carbon target. Global parameter,in CO2/unit,from emissions_min to emissions_max.
if(v[3] <= v[5])//If the technology's emission intensity is equal or lower than the carbon target.
	v[6] = V("Adoption_Subsidy");//Apply adoption subsidies. Global parameter,in percent,from 0% to 100%.
	else
	v[6] = 0;//Else,do not.
v[7] = v[2]*(1-v[6])+(v[1]+v[4])*v[3];//Expected disutility,expressed in money/unit (subsidized cost+carbon tax+intrinsic disutility from emissions)
v[8] = VS(THIS,"allowed_mjt");//The technology is not listed as accepted (boolean: 1=yes,0=no). Memory variable.
if(v[7]==0)//If the technology is not allowed
	v[0] = 0;//Expected fitness is zero.
	else
	v[0] = v[8]/v[7];//Else,expected fitness equals the inverse of the expected disutility,in money terms. Memory variable in fitness measure,real positive value.
RESULT(v[0])

EQUATION("implemented_mjt")
/*
Comment: Is the technology implemented? Memory variable (boolean: 1= implemented,0 = not implemented).
*/
v[1] = MAXS(PARENT,"fitness_mjt");//Expected fitness of the (expected) most fitting technology. Firm variable in fitness measure,real positive value. 
v[2] = VS(THIS,"fitness_mjt");//Expected fitness. Memory variable in fitness measure,real positive value.
v[3] = VS(THIS,"cost_mjt");//Cost per unit. In money/unit,from cost_min to cost_max.
v[4] = VS(THIS,"emissions_mjt");//Emissions per unit. In emissions/unit,from emissions_min to emissions_max.
v[5] = VS(THIS,"technology_mjt");//Technology ID. Memory variable,ID from 0 to 2^N.
v[6] = V("cost_max");//Maximum unit cost. Global parameter,in money/unit,real positive value.
v[7] = V("emissions_max");//Maximum carbon intensity. Global parameter,in emissions/unit,real positive value.
v[8] = VS(PARENT,"firm_ID");//Firm ID (kill firm with ID = 0)
if(v[1] == v[2])//If the technoloy occupying slot m is the most fitting technology
	{
	v[0] = 1;//It is implemented
	WRITES(PARENT,"cost_implemented_jt",v[3]);//The firm implemented technology cost is m's.
	WRITES(PARENT,"emissions_implemented_jt",v[4]);//The firm implemented technology emissions intensity is m's.
	WRITES(PARENT,"technology_implemented_jt",v[5]);//The firm implemented technology cost is m's.
	WRITES(PARENT,"dead_jt",0);//Mark the company as alive
	}
	else
	v[0] = 0;//Mark m as not chosen.
if(v[1] == 0 || v[8] == 0)//If j does not have accepted technologies or is the empty firm.
	{
	WRITES(PARENT,"cost_implemented_jt",v[6]);//The firm implemented technology's cost is the highest.
	WRITES(PARENT,"emissions_implemented_jt",v[7]);//The firm implemented technology's emissions are the highest.
	WRITES(PARENT,"technology_implemented_jt",-1);//The technology is not using any technology: ID -1
	WRITES(PARENT,"dead_jt",1);//Mark the company as dead
	}
RESULT(v[0])

EQUATION("cost_explored_jt")
/*
Comment: Cost per unit of the searched technology. Firm variable in money/unit,from cost_min to cost_max
*/
v[1] = AVES(THIS,"cost_explored_njt");//For each component,average the cost contribution that corresponds to the explored technology. Component variable,from 0 to 1.
v[2] = VS(PARENT,"cost_min");//Lower bound for unit production costs. Global parameter,real positive value.
v[3] = VS(PARENT,"cost_max");//Upper bound for unit production costs,Global parameter,real positive value.
if(VS(THIS,"technology_explored_jt")==0)//If the technology ID is 0 (the state of all components are 0).
	v[0] = v[3];//Assign the maximum cost,(this is the initial technology for all firms)
	else
	v[0] = v[2]+(v[3]-v[2])*v[1];//Otherwise,apply max-min scaling to place the cost within the stipulated range.
RESULT(v[0])

EQUATION("emissions_explored_jt")
/*
Comment: Emissions per unit of the searched technology. Firm variable in CO2/unit,from emissions_min to emissions_max
*/
v[1] = AVES(THIS,"emissions_explored_njt");//For each component,average the emissions contribution that corresponds to the explored technology. Component variable,from 0 to 1.
v[2] = VS(PARENT,"emissions_min");//Lower bound for unit production costs. Global parameter,real positive value.
v[3] = VS(PARENT,"emissions_max");//Upper bound for unit production costs,Global parameter,real positive value.
if(VS(THIS,"technology_explored_jt")==0)//If the technology ID is 0 (the state of all components are 0).
	v[0] = v[3];//Assign the maximum cost,(this is the initial technology for all firms)
	else
	v[0] = v[2]+(v[3]-v[2])*v[1];//Otherwise,apply max-min scaling to place the cost within the stipulated range.
RESULT(v[0])

EQUATION("fitness_explored_jt")
/*
Comment: Expected fitness of the explored technology-Including taxes and subsidies. Firm variable in fitness measures,real positive value.
*/
v[1] = VLS(THIS,"carbon_sensitivity_jt",1);//Firm expected carbon preference. (Lagged) Firm variable in money/CO2,real positive value.
v[2] = VS(THIS,"cost_explored_jt");//Cost per unit of the searched technology. Firm variable in money/unit,from cost_min to cost_maxs
v[3] = VS(THIS,"emissions_explored_jt");//Emissions per unit of the searched technology. Firm variable in CO2/unit,from emissions_min to emissions_max
v[4] = V("Carbon_Tax");//Carbon tax. Global parameter,in money/CO2,real positive value.
v[5] = V("Carbon_Target");//Carbon target. Global parameter,in CO2/unit,from emissions_min to emissions_max.
if(v[3] <= v[5])//If the explored technology's emissions intensity is lower or equal than the carbon target.
	v[6] = V("Adoption_Subsidy");//Apply adoption subsidies. Global parameter,in percent,from 0% to 100%.
	else
	v[6] = 0;//Else,do not.
v[0] = 1/v[2]*(1-v[6])+(v[1]+v[4])*v[3];//Inverse of the expected disutility,expressed in money/unit (subsidized cost+carbon tax+intrinsic disutility from emissions)
RESULT(v[0])

EQUATION("cost_location_jt")
/*
Comment: Cost per unit of the location technology. Firm variable in money/unit,from cost_min to cost_max
*/
v[1] = AVES(THIS,"cost_location_njt");//For each component,average the cost contribution that corresponds to the location technology. Component variable,from 0 to 1.
v[2] = VS(PARENT,"cost_min");//Lower bound for unit production costs. Global parameter,real positive value.
v[3] = VS(PARENT,"cost_max");//Upper bound for unit production costs,Global parameter,real positive value.
if(VS(THIS,"technology_location_jt")==0)//If the technology ID is 0 (the state of all components are 0).
	v[0] = v[3];//Assign the maximum cost,(this is the initial technology for all firms)
	else
	v[0] = v[2]+(v[3]-v[2])*v[1];//Otherwise,apply max-min scaling to place the cost within the stipulated range.
RESULT(v[0])

EQUATION("emissions_location_jt")
/*
Comment: Emissions per unit of the location technology. Firm variable in CO2/unit,from emissions_min to emissions_max
*/
v[1] = AVES(THIS,"emissions_location_njt");//For each component,average the emissions contribution that corresponds to the location technology. Component variable,from 0 to 1.
v[2] = VS(PARENT,"emissions_min");//Lower bound for unit production costs. Global parameter,real positive value.
v[3] = VS(PARENT,"emissions_max");//Upper bound for unit production costs,Global parameter,real positive value.
if(VS(THIS,"technology_location_jt")==0)//If the technology ID is 0 (the state of all components are 0).
	v[0] = v[3];//Assign the maximum cost,(this is the initial technology for all firms)
	else
	v[0] = v[2]+(v[3]-v[2])*v[1];//Otherwise,apply max-min scaling to place the cost within the stipulated range.
RESULT(v[0])

EQUATION("fitness_location_jt")
/*
Comment: Expected fitness of the location technology-Including taxes and subsidies. Firm variable in fitness measures,real positive value.
*/
v[1] = VLS(THIS,"carbon_sensitivity_jt",1);//Firm expected carbon preference. (Lagged) Firm variable in money/CO2,real positive value.
v[2] = VS(THIS,"cost_location_jt");//Cost per unit of the location technology. Firm variable in money/unit,from cost_min to cost_maxs
v[3] = VS(THIS,"emissions_location_jt");//Emissions per unit of the location technology. Firm variable in CO2/unit,from emissions_min to emissions_max
v[4] = V("Carbon_Tax");//Carbon tax. Global parameter,in money/CO2,real positive value.
v[5] = V("Carbon_Target");//Carbon target. Global parameter,in CO2/unit,from emissions_min to emissions_max.
if(v[3] <= v[5])//If the explored technology's emissions intensity is lower or equal than the carbon target.
	v[6] = V("Adoption_Subsidy");//Apply adoption subsidies. Global parameter,in percent,from 0% to 100%.
	else
	v[6] = 0;//Else,do not.
v[0] = 1/v[2]*(1-v[6])+(v[1]+v[4])*v[3];//Inverse of the expected disutility,expressed in money/unit (subsidized cost+carbon tax+intrinsic disutility from emissions)
RESULT(v[0])

EQUATION("technology_explored_jt")
/*
Comment: ID of the explored tecnology. Firm variable,ID,integer from 0 to N-1.
*/
v[0] = 0;//Counter,convert binary into decimal
CYCLES(THIS,cur,"Search_Components")//Cycle through the search box of the firm
{
	v[11] = VS(cur,"component_ID");//Component ID
	v[12] = VS(cur,"state_explored_njt");//Component state. Component variable,binary.
	v[0] = v[0]+v[12]*pow(2,v[11]);//Transform the binary string into a decimal number.
}
RESULT(v[0])

EQUATION("technology_location_jt")
/*
Comment: ID of the location tecnology. Firm variable,ID,integer from 0 to N-1.
*/
v[0] = 0;//Counter,convert binary into decimal
CYCLES(THIS,cur,"Search_Components")//Cycle through the search box of the firm
{
	v[11] = VS(cur,"component_ID");//Component ID
	v[12] = VS(cur,"state_location_njt");//Component state. Component variable,binary.
	v[0] = v[0]+v[12]*pow(2,v[11]);//Transform the binary string into a decimal number.
}
RESULT(v[0])

EQUATION("cost_explored_njt")
/*
Comment: Cost contribution of component n in the explored technology. Component variable,from 0 to 1.
*/
v[1] = 0;//Start counter to find the reference in the value library
CYCLES(THIS,cur,"Search_Partners")
{
	v[10] = VS(cur,"state_explored_partner_knjt");//State of n's k-th partner,corresponding to the explored technology. Partner variable,binary.
	v[11] = VS(cur,"partner_position");//partner k position in the binary string affecting component n
	v[1] = v[1]+v[10]*pow(2,v[11]);//Transform the binary string into a decimal number.
}
cur1 = SEARCH_CND("column_ID",VS(THIS,"component_ID"));//Search in the landscape matrix for column "n",corresponding to the component ID. 
cur2 = SEARCH_CNDS(cur1,"row_ID",v[1]);//In that column,find the row k corresponding to the decimal expression of the binary string of the state combination formed by component n and the next Kn components in the explored technology.
v[0] = VS(cur2,"cost_contribution_kn");//Extract the cost contribution. Landscape matrix parameter,from 0 to 1.
RESULT(v[0])

EQUATION("emissions_explored_njt")
/*
Comment: emissions contribution of component n in the explored technology. Component variable,from 0 to 1.
*/
v[1] = 0;//Start counter to find the reference in the value library
CYCLES(THIS,cur,"Search_Partners")
{
	v[10] = VS(cur,"state_explored_partner_knjt");//State of n's k-th partner,corresponding to the explored technology. Partner variable,binary.
	v[11] = VS(cur,"partner_position");//partner position in the binary string affecting component n. Parter parameter,integer from 0 to Kn-1
	v[1] = v[1]+v[10]*pow(2,v[11]);//Transform the binary string into a decimal number.
}
cur1 = SEARCH_CND("column_ID",VS(THIS,"component_ID"));//Search in the landscape matrix for column "n",corresponding to the component ID. 
cur2 = SEARCH_CNDS(cur1,"row_ID",v[1]);//In that column,find the row k corresponding to the decimal expression of the binary string of the state combination formed by component n and the next Kn components in the explored technology.
v[0] = VS(cur2,"emissions_contribution_kn");//Extract the emissions contribution. Landscape matrix parameter,from 0 to 1.
RESULT(v[0])

EQUATION("state_explored_partner_knjt")
/*
Comment: State of n's k-th partner,corresponding to the explored technology. Partner variable,binary.
*/
v[1] = VS(THIS,"partner_component_ID");//Component ID of n's k-th partner. Partner parameter,ID from 0 to N-1.
cur = SEARCH_CNDS(GRANDPARENT,"component_ID",v[1]);//Find component in the firm search box.
v[0] = VS(cur,"state_explored_njt");//Print the corresponding component state. Firm variable,binary.
RESULT(v[0]) //Print state

//SEARCH BOX

EQUATION("unknown_njt")
/*
Comment: If j changes the state of component n at time t,would the resulting technology be unknown ? Component variable,boolean (1= unknown technology,0 = known technology).
*/
v[1] = VLS(PARENT,"technology_location_jt",1);//Technology ID of the location technology. Lagged firm variable,ID,form 0 to 2^N-1.
v[2] = pow(2,VS(THIS,"component_ID"));//Decimal contribution to the component if it is in state 1.
if(VLS(THIS,"state_location_njt",1)==1) //If the component was at state 1 in the past period...
	v[3] = v[1]-v[2];//Adjust past firm location ID by switching the component's state to 0,
	else
	v[3] = v[1]+v[2];//Else,adjust past firm location ID by switching the component's state to 1.
v[4] = SUM_CNDS(PARENT,"timer_mjt","technology_mjt","==",v[3]);//Sum the time of all memory technologies with the same ID.
if(v[4] > 0)//If there are technologies in j's memory with the same ID (i.e. the sum of timers is positive)
	v[0] = 0;//The resulting technology is known.
	else
	v[0] = 1;//Else,it is unknown.
RESULT(v[0])

EQUATION("advertised_njt")
/*
Comment: If j changes the state of component n at time t,would the resulting technology be advertised by the RP? Component variable,boolean (1= advertised,0 = not advertised).
*/
v[1] = VLS(PARENT,"technology_location_jt",1);//Technology ID of the location technology. Lagged firm variable,ID,form 0 to 2^N-1.
v[2] = VS(THIS,"component_ID");//Component ID. Component parameter,ID from 0 to N-1
cur = SEARCH_CNDS(GRANDPARENT,"advertisement_ID",v[2]);//Find component in the list of the Research Park Advertistements.
v[3] = VS(cur,"advertised_nt");//Is the component advertised ? Research park variable,boolean (1= advertised,0 = not advertised)
v[4] = round(VS(cur,"advertised_state_nt"));//Expected component state to make low-carbon technologies. Research park variable,binary.
if(v[3] == 1 && v[1] != v[4])//If the component is advertised and the state is different from the current location state.
	v[0] = 1;//The resulting technology is advertised
	else
	v[0] = 0;//Else,the resulting  is not advertised
RESULT(v[0])

EQUATION("search_range_jt")
/*
Comment: Number of components changed during firm search. Firm variable in number of components,integer from 0 to 2.
*/
v[1] = SUMS(THIS,"unknown_njt");//Count of components that,after changing their state,the resulting technology is unknown. Component variable,boolean (1= unknown technology,0 = known technology).
v[2] = VS(GRANDPARENT,"N");//Number of components in the NK landscape. Global parameter,positive integer.
v[3] = VLS(THIS,"budget_jt",1);//Budget. Lagged firm variable in money (stock).
v[4] = VS(GRANDPARENT,"Search_Cost");//Search cost (for a single jump). Model parameter,in money,real positive value.
v[5] = VLS(THIS,"beneficiary_jt",1);//Is the firm a policy beneficiary? Lagged firm variable,boolean (1=beneficiary,0=not beneficiary)
v[6] = VS(GRANDPARENT,"Search_Subsidy");//R&D Subsidy. Global parameter,in percent,from 0% to 100%.
if(v[1] > 0)//If the firm has at least one unknown location to explore.
	v[10] = 1;//The desired jump is the local jump.
	else
	v[10] = 2;//Long-jump if the firm knows it is at a sticking point.
v[7] = (pow((1+v[4]),v[10])-1)*(1-v[5])*v[1];//Cost of a the desired jump (squared search cost (search cost is lower than 1)-R&D subsidy if applicable).
if(v[3]>=v[7])//If the firm able to pay for the desired search range.
	v[0] = v[10];//Search range = Desired search range
	else
	v[0] = 0;//Search range = 0
RESULT(v[0])

EQUATION("score_component_njt")
/*
Comment: Component score to be selected for exploration. Component variable,in score measures,real positive value.
*/
v[1] = VS(THIS,"unknown_njt");//Is the technology resulting from changing the component state unknown? Component variable,boolean (1= unknown technology,0 = known technology).
v[2] = VS(THIS,"advertised_njt");//If j changes the state of component n at time t,would the resulting technology be advertised by the RP? Component variable,boolean (1= advertised,0 = not advertised).
if(v[1]==0)//If the technology resulting from changing the component state is known...
	v[10] = uniform(0,0.1);//Assign a low selection score.
	else
	v[10] = uniform(0.9,1);//Else,assign a medium selection score.
if(v[1]==1 && v[2]==1)//If the technology resulting from changing the component state is known and advertised by the Research Park... 
	v[0] = uniform(1.5,2);//Assign a high selection score.
	else
	v[0] = v[10];//Else,assign a low or medium score.
RESULT(v[0])

EQUATION("state_explored_njt")
/*
Comment: State of component n during firm search. Component variable,binary.
*/
v[1] = VS(THIS,"search_range_jt");//Number of components changed during firm search. Firm variable in number of components,integer from 0 to 2.
v[2] = VS(THIS,"score_component_njt");//Component score to be selected for exploration. Component variable, in score measures, real positive value.
v[3] = MAXS(PARENT,"score_component_njt");//Maximum component score. Firm variable, in score measures, real positive value (selected for change).
v[4] = MAX_CNDS(PARENT,"score_component_njt","score_component_njt","<",v[3]);//Second largest component score. Firm variable, in score measures, real positive value (selected if the jump is long).
v[5] = VLS(THIS,"state_location_njt",1);//Component state of the location technology. Lagged component variable, binary.
if(v[1] >= 1 && v[2] == v[3])//If j is searching, and the component has the highest score...
	v[10] = 1-v[5];//Change the state of the component
	else
	v[10] = v[5];//Else, do not change the state of the component
if(v[1] == 2 && v[2] == v[5])//If j is doing a long-jump and the component has the second largest selection score...
	v[0] = 1-v[5];//Change the state of the component
	else
	v[0] = v[10];//Do not change the state of the component
RESULT(v[0])

EQUATION("state_location_njt")
/*
Comment:Component state of the location technology. Component variable, binary.
*/
v[1] =VLS(THIS,"state_location_njt",1);//Component state of the location technology. Lagged component variable, binary.
v[2] = VS(THIS,"state_explored_njt");//State of component n during firm search. Component variable, binary.
v[3] = VLS(PARENT,"fitness_location_jt",1);//Expected fitness of the location technology. LAgged Firm variable in fitness measures, real positive value.
v[4] = VS(PARENT,"fitness_explored_jt");//Expected fitness of the explored technology. Firm variable in fitness measures, real positive value.
v[5] = VS(THIS,"cost_explored_njt");//Cost contribution of component n in the explored technology. Component variable, from 0 to 1.
v[6] = VS(THIS,"emssions_explored_njt");//Pollution contribution of component n in the explored technology. Component variable, from 0 to 1.
if(v[3]>v[4])//If the expected fitness of the searched technology is strictly lower than the previous location technology. 
	v[0] = v[1];//Do not adopt
	else
	{
	v[0] = v[2];//Adopt
	WRITES(THIS,"cost_location_njt",v[5]);//And print new cost contribution
	WRITES(THIS,"emissions_location_njt",v[6]);//And print new emissions contribution
	}
RESULT(v[0])

EQUATION("memory_jt")
/*
Comment: Command to update memory. Firm action: Fill new memory slot (if a technology is discovered), substituting an existing slot if necessary.
*/
v[1] = VS(THIS,"technology_explored_jt");//ID of the explored technology. Firm variable, ID in [0,N-1]
v[2] = VLS(THIS,"technology_location_jt",1);//ID of the location technology. Lagged variable, ID in [0,N-1]
v[3] = 0;//Initialize counter for technologies with the same ID (avoid redundancies).
CYCLES(THIS,cur1,"Memory")//Cycle through memory slots,
	{
	v[10] = VS(cur1,"technology_mjt");//Get technology ID for each slot,
	if(v[10]==v[1])//If the searched technology is already in the memory
		v[3] = v[3]+1;//Add to counter
		else
		v[3] = v[3];//Else, ignore.
	}
v[4] = MAXS(THIS,"score_memory_mjt");//Maximum updating score in the memory list. Memory variable, in score measures.
cur = SEARCH_CNDS(THIS,"score_memory_mjt",v[4]);//Find the memory slot with the highest selection score.
v[5] = VS(THIS,"cost_explored_jt");//Cost of the explored technology. Firm variable, in money/unit, in [cost_min,cost_max]
v[6] = VS(THIS,"emissions_explored_jt");//Emissions of the explored technology. Firm variable, in CO2/unit, in [emissions_min,emissions_max]
if(v[1] == v[2] || v[3] > 0)//If j has not explored a new technology.
	v[0] = v[3];//Do not update memory
	else
	{
	WRITES(cur,"technology_mjt",v[1]);//Print technology ID into the selected slot.
	WRITES(cur,"cost_mjt",v[5]);//Print unit costs into the selected slot.
	WRITES(cur,"emissions_mjt",v[6]);//Print emissions intensity into the selected slot.
	WRITES(cur,"timer_mjt",1);//Set timer to 1.
	v[0] = v[3];//Mark as TRUE.
	}
RESULT(v[0])

EQUATION("timer_mjt")
/*
Comment: Timer since the last time a technology was used or explored. Memory variable, in number of time-steps, in non-negative integer values.
*/
v[1] = VS(THIS,"technology_mjt");//ID of the technology occupying the memory slot m. Memory variable, ID in [0,N-1]
v[2] = VLS(THIS,"timer_mjt",1);//Timer since the last time a technology was used or explored. Lagged memory variable, in number of time-steps, in non-negative integer values.
if(v[1] == -1)//If the memory slot has no technology.
	v[10] = 0;//Keep timer at 0.
	else
	v[10] = v[2]+1;//Else,add a unit.
v[3] = VLS(PARENT,"technology_explored_jt",1);//ID of the explored technology. Lagged firm variable, ID in [0,N-1] 
v[4] = VLS(PARENT,"technology_location_jt",1);//ID of the location technology. Lagged firm variable, ID in [0,N-1] 
v[5] = VLS(PARENT,"technology_implemented_jt",1);//ID of the implmemented technology. Lagged firm variable, ID in [0,N-1] 
if(v[1] == v[3] || v[1] == v[4] || v[1] == v[5])//If the technology is being searched,used as locaiton,or implemented
	v[0] = 1;//Set timer back to 1.
	else
	v[0] = v[10];//Else,keep timer as before.
RESULT(v[0])

EQUATION("score_memory_mjt")
/*
Comment: Memory slot updating score. Memory variable, in score measures.
*/
v[1] = VS(THIS,"timer_mjt");//Timer since the last time a technology was used or explored. Memory variable, in number of time-steps, in non-negative integer values.
v[2] = VS(THIS,"technology_mjt");//ID of the technology occupying the memory slot m. Memory variable, ID in [0,N-1]
v[3] = VS(THIS,"memory_ID");//Slot ID
if(v[2] == -1)//If the slot is empty
	v[0] = v[3];//Use the ID to sort.
	else
	v[0] = -1/(1+v[1]);//Else,use the timer to sort. 
RESULT(v[0])

//COMPETITION

EQUATION("price_jt")
/*
Comment: Retail price (including polciy effect). Firm variable in money/unit, real positive value.
*/
v[1] = VS(THIS,"cost_implemented_jt");//Cost of the implemented technology. Firm variable in money/unit, in [cost_min,cost_max].
v[2] = VLS(THIS,"markup_jt",1);//mark-up. Lagged firm variable, in percent, real positive value.
v[3] = VLS(THIS,"beneficiary_jt",1);//j is a policy beneficiary. Lagged firm variable, boolean (1=beneficiary, 0=not beneficiary)
v[4] = VS(GRANDPARENT,"Adoption_Subsidy");//Adoption subsidy. Global parameter, in percent, in [0,100]%
v[5] = VS(GRANDPARENT,"Carbon_Tax");//Carbon tax. Global parameter, in money/CO2, real positive value.
v[6] = VS(THIS,"emissions_implemented_jt");//Carbon intensity of the implemented technology. Firm variable in CO2/unit, in [emissions_min,emissions_max]
v[0] = v[1]*(1+v[2])*(1-v[3]*v[4])+v[5]*v[6];//Cost+mark-up pricing - adoption subsidy (if applicable)+carbon tax
RESULT(v[0])

EQUATION("markup_jt")
/*
Comment: mark-up. Firm variable, in percent, real positive value.
*/																	
v[1] = VLS(THIS,"markup_jt",1);//mark-up. Lagged firm variable, in percent, real positive value.
v[2] = VS(GRANDPARENT,"Adjustment_Speed");//Adjustment speed. Global parameter, scale, real positive value.
v[3] = VS(THIS,"market_share_jt");//Market share. Firm variable, in percent, in [0,100]%
v[4] = VLS(THIS,"market_share_jt",1);//Market share. Lagged firm variable, in percent, in [0,100]%
if(v[4] > 0)//Avoid invalid results (dead firms have a market share = 0)
	v[0] = v[1]*(1+v[2]*(v[3]-v[4])/v[4]);//Mark-up is pro-cyclical to changes in the market share.
	else
	v[0] = VS(GRANDPARENT,"markup");//If the result is invalid, write the default markup.
RESULT(v[0])

EQUATION("fitness_jt")
/*
Comment: True fitness of the product offered by firm j. Firm variable, in fitness measures, real positive value.
*/
v[1] = VS(GRANDPARENT,"carbon_sensitivity");//Consumer sensitivity to carbon emissions. Global parameter on money/CO2, real positive value.
v[2] = VS(THIS,"price_jt");//Retail price (including polciy effect). Firm variable in money/unit, real positive value.
v[3] = VS(THIS,"emissions_implemented_jt");//Carbon intensity of the implemented technology. Firm variable in CO2/unit, in [emissions_min,emissions_max]
v[4] = VS(THIS,"firm_ID");//Firm ID (ignore the empty firm). Firm parameter, ID in [0,J-1]
v[5] = v[2]+v[1]*v[3];//Consumer disutility from consumption, expressed in money. Price+disutility from emissions.
if(v[4] == 0 || v[5] == 0)//Avoid invalid results and ignore the empty firm.
	v[0] = 0;//0 Fitness if such is the case
	else
	v[0] = 1/v[5];//Else,the fitness equals inverse of the consumer disutility.
RESULT(v[0])

EQUATION("fitness_t")
/*
Comment: Average of firms' fitness-weighted by the past market share. Market variable, in fitness measures, real positive value.
*/
v[0] = 0;//Start counter for the weighted average of fitnesses
v[1] = 0;//Start counter for re-weighting after discarding dead firms
CYCLES(THIS,cur,"Firms")//Cycle through firms
{
	v[21] = VLS(cur,"market_share_jt",1);//Market share. Lagged firm variable, in percent, in [0,100]%
	v[22] = VS(cur,"dead_jt");//Is the firm dead? Firm variable, boolean (1=dead,0=alive)
	if(v[22] == 0)//If the firm is alive
		v[1] = v[1]+v[21];//Add to the combined lagged market share of currently alive firms.
		else
		v[1] = v[1];//Else, ignore.
}
CYCLES(THIS,cur,"Firms")//Cycle through firms
{
	v[11] = VS(cur,"fitness_jt");//True fitness of the product offered by firm j. Firm variable, in fitness measures, real positive value.
	v[12] = VLS(cur,"market_share_jt",1);//Market share. Lagged firm variable, in percent, in [0,100]%
	v[13] = VS(cur,"dead_jt");//Is the firm dead? Firm variable, boolean (1=dead,0=alive)
	if(v[1] == 0)//If the combined market share of alive firms is 0
		v[14] = v[12];//Ignore and get the past market share, this is probably just at initialization
		else
		v[14] = v[12]*(1-v[13])/v[1];//Else, re-define the market share as the relative market share among alive firms (0 if dead).	
	v[0] = v[0]+v[11]*v[14];//Sum the fitness weighted by the past market shares.
	}
RESULT(v[0]) 

EQUATION("market_share_jt")
/*
Comment: /Market share. Firm variable, in percent, in [0,100]%
*/
v[1] = 0;//Start counter for re-weighting after discarding dead firms
CYCLES(PARENT,cur,"Firms")//Cycle through firms (from the market)
{
	v[11] = VLS(cur,"market_share_jt",1);//Market share. Lagged firm variable, in percent, in [0,100]%
	v[12] = VS(cur,"dead_jt");//Is the firm dead? Firm variable, boolean (1=dead,0=alive)
	if(v[12] == 0)//If the firm is alive
		v[1] = v[1]+v[11];//Add to the combined lagged market share of currently alive firms.
		else
		v[1] = v[1];//Else, ignore.
}
v[2] = VLS(THIS,"market_share_jt",1);//Market share. Lagged firm variable, in percent, in [0,100]%
v[3] = VS(THIS,"dead_jt");//Is the firm dead? Firm variable, boolean (1=dead,0=alive)
if(v[1] == 0)//If the combined market share of alive firms is 0
	v[4] = v[2];//Ignore and get the past market share, this is probably just at initialization
	else
	v[4] = v[2]*(1-v[3])/v[1];//Else, re-define the market share as the relative market share among alive firms (0 if dead).
v[5] = VS(GRANDPARENT,"Adjustment_Speed");//Adjustment speed. Global parameter, scale, real positive value.
v[6] = VS(THIS,"fitness_jt");//True fitness of the product offered by firm j. Firm variable, in fitness measures, real positive value.
v[7] = VS(PARENT,"fitness_t");//Average of firms' fitness-weighted by the past market share. Market variable, in fitness measures, real positive value.
if(v[7]==0)//Avoid invalid results
	v[0] = (1-v[2])/(VS(GRANDPARENT,"J")-SUMS(PARENT,"dead_jt"));//In case the result is invalid (probably at initialization) then give to all alive firms the same market share (ignoring dead firms).
	else
	v[0] = (1-v[2])*v[4]*(1+v[5]*(v[6]-v[7])/v[7]);//Else the market share (relative with respect to alive firms) is updated using the replciator dynamics (ignoring dead firms).
RESULT(v[0])

EQUATION("profits_jt")
/*
Comment: Operating profits -before R&D expenditures. Firm variable in money/timestep, real positive value.
*/
v[1] = VS(THIS,"units_produced_jt");//Quantites produced. Firm variable in manufactured good units/timestep, real positive value.
v[2] = VS(THIS,"price_jt");//Retail price (including polciy effect). Firm variable in money/unit, real positive value.
v[3] = VS(THIS,"cost_implemented_jt");//Cost per unit of the implemented technology. Firm, in money/unit, real positive value.
v[4] = VS(THIS,"emissions_implemented_jt");//Carbon intensity of the implemented technology. Firm variable, in CO2/unit, real positive value.
v[5] = VS(GRANDPARENT,"Carbon_Tax");//Carbon ax. Global parameter in money/CO2, real positive value.
v[0] = v[1]*(v[2]-v[3]-v[4]*v[5]);//Operating profits = units produced*(price - produciton costs - taxes)
RESULT(v[0])

EQUATION("units_produced_jt")
/*
Comment: Quantites produced. Firm variable in manufactured good units/timestep, real positive value.
*/
v[1] = VS(THIS,"market_share_jt");//Market share. Firm variable, in percent, in [0,100]%
v[2] = VS(THIS,"price_jt");//Retail price (including polciy effect). Firm variable in money/unit, real positive value.
if(v[2] == 0)//Avoid invalid results.
	v[0] = 0;//Invalid result
	else
	v[0] = v[1]/v[2];//Revenues (market share = revenues because market size = 1) divided by price.
RESULT(v[0])

EQUATION("budget_jt")
/*
Comment: Firm budget (perpetual accummulation). Firm variable.
*/
v[1] = VS(THIS,"dead_jt");//Is the firm dead? Firm variable, boolean (1=dead,0=alive)
v[2] = VLS(THIS,"budget_jt",1);//Budget. Lagged firm variable, in money (stock), real positive value.
v[3] = VS(THIS,"profits_jt");//Operating profits -before R&D expenditures. Firm variable in money/timestep, real positive value.
v[4] = VS(THIS,"search_range_jt");//Number of components changed during firm search. Firm variable in number of components, integer from 0 to 2.
v[5] = VS(GRANDPARENT,"Search_Cost");//Search cost (for a single jump). Model parameter,in money,real positive value.
v[6] = VLS(THIS,"beneficiary_jt",1);//j is a policy beneficiary. Lagged firm variable, boolean (1=beneficiary, 0=not beneficiary)
v[7] = VS(GRANDPARENT,"Search_Subsidy");//R&D Subsidy. Global parameter,in percent,from 0% to 100%.
if(v[1] == 1)//If the firm is dead
	v[0] = 0;//Ignore
	else
	v[0] = v[2]+v[3]-(pow(1+v[5],v[4])-1)*(1-v[6]*v[7]);//Budget = Past+OP-Search Costs (subsidized if applicable)
RESULT(v[0])

//UPDATE OF EXPECTED CARBON SENSITIVITY

EQUATION("score_competitor_hjt")
/*
Comment: Competitor score to be selected for comparison. Competitor variable, in score measures, real positive value.
*/
v[1] = VS(THIS,"competitor_ID");//Competitor ID. Competitor parameter, ID, integer in [0,J-1]
cur = SEARCH_CNDS(GRANDPARENT,"firm_ID",v[1]);//Find matching firm
v[2] = VS(cur,"dead_jt");//Is the firm dead? Firm variable, boolean (1=dead,0=alive)
v[3] = VS(cur,"market_share_jt");//Market share. Firm variable, in percent, in [0,100]%
v[4] = VS(cur,"price_jt");//Retail price (including polciy effect). Firm variable in money/unit, real positive value.
v[5] = VS(PARENT,"market_share_jt");//Market share. Firm variable, in percent, in [0,100]%
v[6] = VS(PARENT,"price_jt");//Retail price (including polciy effect). Firm variable in money/unit, real positive value.
if(v[3]>v[5] && v[4]!=v[6])//If the competitor has higher market share than the firm, and a different price
	v[0] = (1-v[2])*pow(abs(v[4]-v[6]),-1);//The selection score, for non-dead firms, is equal to the inverse of the absolute price difference (plus some epsilon to avoid wrong results)
	else
	v[0] = 0;//Else, the score equals the epsilon.
RESULT(v[0])

EQUATION("carbon_sensitivity_jt")
/*
Comment: Subjective weight to carbon emissions. Firm variable,in money/CO2,real positive value.
*/
v[1] = VLS(THIS,"carbon_sensitivity_jt",1);//Subjective weight to carbon emissions. Lagged firm variable,in money/CO2, real positive value.
v[2] = MAXS(THIS,"score_competitor_hjt");//Maximum Competitor score to be selected for comparison. Competitor variable, in score measures, real positive value.
v[3] = VS(GRANDPARENT,"Adjustment_Speed");//Adjustment speed. Global parameter, scale, real positive value.
v[4] = VS(THIS,"emissions_implemented_jt");//Carbon intensity of the implemented technology. Firm variable, in CO2/unit, real positive value.
cur = SEARCH_CNDS(THIS,"score_competitor_hjt",v[2]);//Select the competitor with the highest score score.
v[5] = VS(cur,"competitor_ID");//Competitor ID. Competitor parameter, ID, integer in [0,J-1]
cur1 = SEARCH_CNDS(PARENT,"firm_ID",v[5]);//Find matching firm.
v[6] = VS(cur1,"emissions_implemented_jt");//Carbon intensity of the implemented technology. Firm variable, in CO2/unit, real positive value.
if(v[2] == 0 || v[6] == 0)//If all competitors do not qualify for comparison, or the results are invalid
	v[0] = v[1];//Do not update the expected weight to carbon emissions.
	else
	v[0] = v[1]*(1+v[3]*(v[4]/v[6])-1);//Else, update
RESULT(v[0])

//POLICIES

EQUATION("beneficiary_jt")
/*
Comment: Is j a policy beneficiary? Firm variable, boolean (1=beneficiary, 0=not beneficiary)
*/
v[1] = VS(THIS,"emissions_implemented_jt");//Carbon intensity of the implemented technology. Firm variable, in CO2/unit, real positive value.
v[2] = VS(GRANDPARENT,"Carbon_Target");////Carbon target. Global parameter,in CO2/unit,from emissions_min to emissions_max.
if(v[1]>v[2])//If the firm carbon intensity is above the policy target.
	v[0] = 0;//The firm is not a policy beneficiary.
	else
	v[0] = 1;//Else,it is
RESULT(v[0])

EQUATION("RP_memory_t")
/*
Comment: Action: Update research park memory. Market action. 
*/
v[0] = 0;//Start counter
v[1] = VS(PARENT,"Research_Park_Threshold");//Certainty threshold of the Research Park. Global parameter, in percent, real value in [0,100]%
v[2] = VS(PARENT,"Command_Control_Speed");//Speed at which regulation becomes more stringent. Global parameter, in percent, real value in [0,100]%
v[3] = VS(PARENT,"N");//Number of components in the NK landscape. Global parameter, in number of components, positive integer.
CYCLES(THIS,cur,"Firms")//Cycle through firms
{
	v[10] = VLS(cur,"technology_implemented_jt",1);//ID of the implemented technology. Lagged firm variable, ID, integer in [0,2^N-1]
	v[11] = VLS(cur,"cost_implemented_jt",1);//Cost of the implemented technology. Lagged firm variable, money/unit, real value in [cost_min,cost_max]
	v[12] = VLS(cur,"emissions_implemented_jt",1);//Emissions intensity of the implemented technology. Lagged firm variable, CO2/unit, real value in [emissions_min,emissions_max]
	v[13] = VS(cur,"dead_jt");//Is the firm dead? Firm variable, boolean (1=dead,0=alive)
	v[14] = SUM_CNDS(THIS,"cost_RPM","technology_RPM","==",v[10]);//Check if the technology is already in the research park memory (by getting the sum of something that is non-zero)
	if(v[14] > 0 || v[10] < 0 || v[13] == 1 || (v[1] == 0 && v[2] == 0))//If the technology does not exist, or the firm is dead, or the technology is already in MRP, or neither the research park nor command and control are in place
		v[0] = v[0];//Do not update counter.
		else
	{
		v[0] = v[0]+1;//Update counter
		cur1 = ADDOBJS(THIS,"Research_Park_Memory");//Set pointer
		WRITES(cur1,"technology_RPM",v[10]);//Print ID
		WRITES(cur1,"cost_RPM",v[11]);//Print cost
		WRITES(cur1,"emissions_RPM",v[12]);//Print carbon intensity
		WRITES(cur1,"firm_RPM",v[13]);//Print discovering firm ID
		cur2 = ADDNOBJS(cur1,"Research_Park_Memory_Components",v[3]-1);//Create sub-objects (Component, needed to identify the components that are relevant for the research park)
	}
}
RESULT(v[0])

EQUATION("score_ID_RPM")
/*
Comment: Random number generated to sort the components and make a corresponding ID. Memory parameter, in score measures, real number in (0,1)
*/
v[0] = uniform(0,1);//Generate random number
PARAMETER//fix
RESULT(v[0])

EQUATION("Component_ID_RPM")
/*
Comment: Component ID in the Research Park Memory. Memory parameter, ID, integer in [0,N-1]
*/
v[0] = 0;//Start counter
v[1] = VS(THIS,"score_ID_RPM");//Random number generated to sort the components and make a corresponding ID. Memory parameter, in score measures, real number in (0,1)
CYCLES(PARENT,cur,"Research_Park_Memory_Components")//Cycle through the other components to see where it ranks.
{
	v[11] = VS(cur,"score_ID_RPM");//Random number generated to sort the components and make a corresponding ID. Memory parameter, in score measures, real number in (0,1)
	if(v[11]<v[1])//If the current component has a lower score
		v[0] = v[0]+1;//Increase ID by one
		else
		v[0] = v[0];//Else, ignore
}
PARAMETER//Fix
RESULT(v[0])

EQUATION("state_component_RPM")
/*
Comment: State of the compnent n in the technology recorded in the Research Park memory. Memory parameter, binary. 
*/
v[1] = round(VS(PARENT,"technology_RPM")/pow(2,VS(THIS ,"Component_ID_RPM"))-0.499999)/2-round(round(VS(PARENT,"technology_RPM")/pow(2,VS(THIS,"Component_ID_RPM"))-0.499999)/2+0.1);//Trick to convert from decimal (technology ID) to binary, for a given binary string position (component_ID_RPM)											
if(v[1] == 0)
	v[0] = 0;
	else
	v[0] = 1;
PARAMETER//Fix
RESULT(v[0])

EQUATION("advertised_RPM")
/*
Comment: Is the technology, in the Research Park memory, advertised? Memory parameter, boolean (1=advertised, 0=not advertised)
*/
v[1] = VS(GRANDPARENT,"Carbon_Target");//Carbon target. Global parameter,in CO2/unit,from emissions_min to emissions_max.
v[2] = VS(THIS,"emissions_RPM");//Carbon intensity of the technology stored in the Research Park memory. Memory parameter, in CO2/unit, real value in [emissions_min,emissions_max]
if(v[2]<=v[1])//If the technology copes with the carbon target...
	v[0] = 1;//It is advertised
	else
	v[0] = 0;//Else, it is not
RESULT(v[0])

EQUATION("advertised_state_nt")
/*
Comment: Expected state to render green technologies. Advertisement variable, in "stateness" spectrum, real value in (0,1) 
*/
v[1] = SUMS(PARENT,"advertised_RPM");//Check if there are any green products in the Research Park Memory.
v[2] = VS(THIS,"advertisement_ID");//ID of the component being examined for advertisement. Advertisement parameter, ID, integer in [0,N-1]
v[3] = 0;//Start counter
CYCLES(PARENT,cur,"Research_Park_Memory")//Scan through the research park memory
{
	v[11] = VS(cur,"advertised_RPM");//Is the technology, in the Research Park memory, advertised? Memory parameter, boolean (1=advertised, 0=not advertised)
	CYCLES(cur,cur1,"Research_Park_Memory_Components")//Scan through the components of each technology to find the matching component
	{
		v[21] = VS(cur1,"Component_ID_RPM");//Component ID in the Research Park Memory. Memory parameter, ID, integer in [0,N-1]
		v[22] = VS(cur1,"state_component_RPM");// State of the compnent n in the technology recorded in the Research Park memory. Memory parameter, binary. 
		if(v[11] == 1 && v[2] == v[21])//If the technology is advertised, and the component examined matches the component that must be advertised,
			v[3] = v[3]+v[22];//Add the state of the component to the counter
			else
			v[3] = v[3];//Else, ignore
	}
}
if(v[1]>0)//If there are any green products in the Research Park Memory...
	v[0] = v[3]/v[1];//Get the average component state
	else
	v[0] = -1;//Else, classify the componet as "inconclussive"
RESULT(v[0])

EQUATION("advertised_nt")
/*
Comment: Is the component advertised? Research park advertisement variable,boolean (1= advertised,0 = not advertised)
*/
v[1] = VS(PARENT,"Research_Park_Threshold");//Certainty threshold of the Research Park. Global parameter, in percent, real value in [0,100]%
v[2] = VS(THIS,"advertised_state_nt");//Expected state to render green technologies. Advertisement variable, in "stateness" spectrum, real value in (0,1) 
if((v[2] != -1) && (v[2]>=v[1] || v[2]<=(1-v[1])))//If the expectation is not inconclussive, and lies within the confidence threshold.
	v[0] = 1;//The component is advertised
	else
	v[0] = 0;//Else it is not
RESULT(v[0])

EQUATION("emissions_legal_t")
/*
Comment: Maximum carbon intensity permited by the regulator. Market variable, in CO2/unit, real value in [emissions_min,emissions_max]
*/
v[1] = VS(PARENT,"Carbon_Target");//Carbon intensity policy target. Global parameter, in CO2/unt, real value in [emissions_min,emissions_max]
v[2] = VS(PARENT,"Command_Control_Speed");//Speed at which regulation becomes more stringent. Global parameter, in percent, real value in [0,100]%
v[3] = VLS(THIS,"emissions_legal_t",1);//Maximum carbon intensity permited by the regulator. Lagged market variable, in CO2/unit, real value in [emissions_min,emissions_max]
v[0] = max(v[1],(1-v[2])*v[3]);//Apply percentage discount on each period, having the target as a limit.
RESULT(v[0])

//MARKET-LEVEL VARIABLES

EQUATION("HHI_t")
/*
Comment: Herfindahl-Hirschman Index. Market variable, in percent, real value in [0,100]%
*/
v[0] = 0;//Start counter.
CYCLES(THIS,cur,"Firms")//Cycle through firms
{
	v[11] = pow(VS(cur,"market_share_jt"),2);//(Squared) market share. Firm variable, in percent, real value in [0,100]%
	v[0] = v[0]+v[11];//Sum them.
}
RESULT(v[0])

EQUATION("emissions_flow_t")
/*
Comment: Total industry carbon emissions. Market variable, in CO2/timestep, real positive value. 
*/
v[0] = 0;//Start counter
CYCLES(THIS,cur,"Firms")//Cycle through firms
{
	v[10] = VS(cur,"units_produced_jt");//Units produced. Firm variable, in units/timestep, real positive value.
	v[11] = VS(cur,"emissions_implemented_jt");//Carbon intensity of the implemented technology. Firm variable, in CO2/unit, real positive value.
	v[0] = v[0]+v[10]*v[11];//Total emissions (flow) Carbon intensity times quantity sold
}
RESULT(v[0])

EQUATION("units_produced_t")
/*
Comment: Total industry units produced. Market variable, in units/timestep, real positive value.
*/
v[0] = SUMS(THIS,"units_produced_jt");//(Sum) Units produced. Firm variable, in units/timestep, real positive value.
RESULT(v[0])

//POLICY EXPENDITURE VARIABLES

EQUATION("expenditure_search_subsidy_t")																				
/*
Comment: Expenditure on R&D subsidies. Market variable, in money/timestep, real positive value.
*/
v[1] = VS(PARENT,"Search_Subsidy");//Subsidy on R&D expenditures. Global parameter, in percent, real value in [0,100]%
v[2] = VS(PARENT,"Search_Cost");//Search costs. Global parameter, in money/component change, real positive value.
v[0] = 0;//Start counter
CYCLES(THIS,cur,"Firms")//Cycle through firms
{
	v[11] = VS(cur,"beneficiary_jt");//Is the firm a beneficiary? Firm variable, boolean (1=yes,0=no)
	v[12] = VS(cur,"search_range_jt");//Search range. Firm variable, in component changes/timestep, integer in [0,2]
	v[0] = v[0]+v[1]*v[11]*(pow(1+v[2],v[12])-1);//Sum subsidy costs.
}
RESULT(v[0])

EQUATION("expenditure_adoption_subsidy_t")
/*
Comment: Expenditure on adoption subsidies. Market variable, in money/timestep, real positive value.
*/
v[0] = 0;//Start counter
v[1] = VS(PARENT,"Adoption_Subsidy");//Subsidy on adoption expenditures. Global parameter, in percent, real value in [0,100]%
CYCLES(THIS,cur,"Firms")//Cycle through firms
{
	v[11] = VS(cur,"beneficiary_jt");//Is the firm a beneficiary? Firm variable, boolean (1=yes,0=no)
	v[12] = VS(cur,"price_jt");//Retail price (post-policy). Firm variable, in money/unit, real positive value.
	v[13] = VS(cur,"units_produced_jt");//Quantity produced. Firm variable, in units/timestep, real positive value.
	v[0] = v[0]+v[1]*v[11]*v[13]*v[12]/(1-v[1]);//Total cost = subsidized price * quantity produced.
}
RESULT(v[0])

EQUATION("expenditure_carbon_tax_t")
/*
Comment: Expenditure (negative) on carbon taxes. Market variable, in money/timestep, real negative value.
*/
v[0] = 0;//Start counter
v[1] = VS(PARENT,"Carbon_Tax");//Carbon tax. Global variable, in money/CO2, real positive value.
CYCLES(THIS,cur,"Firms")//Cycle through firms
{
	v[10] = VS(cur,"units_produced_jt");//Quantity produced. Firm variable, in units/timestep, real positive value.
	v[11] = VS(cur,"emissions_implemented_jt");//Carbon intensity of the implemented technology. Firm variable, in CO2/unit, real value in [emissions_min,emissions_max]
	v[0] =v[0]+-v[10]*v[11]*v[1];//Total tax expenditure = (Negative sum) quantity * emisisons * tax
}
RESULT(v[0])
 
EQUATION("expenditure_command_control_t")
/*
Comment: Expenditure on command and control. Market variable, in money/timestep, real positive value.
*/
v[1] = VS(PARENT,"Search_Cost");//Search costs. Global parameter, in money/component change, real positive value.
v[2] = VS(THIS,"RP_memory_t");//New technologies included in the Research Park memory. Market variable in number of technologies, integer in [0,J-1]
v[3] = VS(PARENT,"Command_Control_Speed");//Speed at which regulation becomes more stringent. Global parameter, in percent, real value in [0,100]%
v[4] = VS(PARENT,"Research_Park_Threshold");//Certainty threshold of the Research Park. Global parameter, in percent, real value in [0,100]%
if(v[3] > 0)//If command and control is activated
	v[10] = v[1]*v[2];//Research cost incurred in the exploraiton of each technology in RPM
	else
	v[10] = 0;//Else,no cost.
if(v[4] == 0)//If the research park is not activated
	v[0] = v[10];//The full cost is assigned to command and control
	else
	v[0] = v[10]/2;//If both are activated, they split the costs
RESULT(v[0])

EQUATION("expenditure_research_park_t")
/*
Comment: Expenditure on research park. Market variable, in money/timestep, real positive value.
*/
v[1] = VS(PARENT,"Search_Cost");//Search costs. Global parameter, in money/component change, real positive value.
v[2] = VS(THIS,"RP_memory_t");//New technologies included in the Research Park memory. Market variable in number of technologies, integer in [0,J-1]
v[3] = VS(PARENT,"Command_Control_Speed");//Speed at which regulation becomes more stringent. Global parameter, in percent, real value in [0,100]%
v[4] = VS(PARENT,"Research_Park_Threshold");//Certainty threshold of the Research Park. Global parameter, in percent, real value in [0,100]%
if(v[4] > 0)//If the research park is activated
	v[10] = v[1]*v[2];//Research cost incurred in the exploraiton of each technology in RPM
	else
	v[10] = 0;//Else,no cost.
if(v[3] == 0)//If command and control is not activated
	v[0] = v[10];//The full cost is assigned to the research park
	else
	v[0] = v[10]/2;//If both are activated, they split the costs
RESULT(v[0])

EQUATION("expenditure_total_t")
/*
Comment: Government expenditure. Market variable in money/timestep, real positive value.
*/
v[1] = VS(THIS,"expenditure_search_subsidy_t");//Expenditure on R&D subsidies
v[2] = VS(THIS,"expenditure_adoption_subsidy_t");//Expenditure on adoption subsidies
v[3] = VS(THIS,"expenditure_carbon_tax_t");//Carbon tax revenues
v[4] = VS(THIS,"expenditure_command_control_t");//Expenditure on Command & Ccontrol
v[5] = VS(THIS,"expenditure_research_park_t");//Expenditure on the research park
v[0] = v[1]+v[2]+v[3]+v[4]+v[5];//Sum flows
RESULT(v[0])

EQUATION("real_expenditure_total_t")
/*
Comment: Real government expenditure. Market variable, in units/timestep, real positive value.
*/
v[1] = VS(THIS,"expenditure_total_t");//Government expenditure. Market variable in money/timestep, real positive value.
v[2] = WHTAVES(THIS,"price_jt","market_share_jt");//Average retail prices, weighted by the firm market share (proxy for price index). Market variable in money/unit, real positive value.
if(v[2] == 0)//If denominator is 0
	v[0] = 0;//Avoid invalid results
	else
	v[0] = v[1]/v[2];//Else,get ratio.
RESULT(v[0])

MODELEND

//do not add Equations in this area

void close_sim(void)
{
	//close simulation special commands go here
}

